---
layout: default_post
---

随着前端技术的发展，Web 的使用体验越来越接近原生 APP。

两三年前，当被问及 Web 还缺少哪些移动端特性时，**推送**可能是最频繁被提及的特性之一。但如今，**推送**早已经成了越来越多的网站重要的部分。

Chrome 从 52 起开放了消息推送接口，结合 `Service Worker` 可在离线状态下（未打开页面）也可以接收推送消息。这一特性的加入，对于开发更接近原生体验的 PWA 应用，可以说是一个巨大的飞跃。然而由于各家浏览器的支持性（及 google 服务在国内可用性）问题，这一革命性特性在各网站却难以接入。

好消息是去年年底，iOS 11.3 及 macOS 10.13.4 终于宣布将默认支持 `Service Worker`，这对于 PWA 的应用无疑有巨大的推动力。作为 PWA 的最重要特性之一，离线推送在工程中的使用必将迎来一轮大范围的爆发。

## 实现

### 1. 注册 Service Worker

这个没什么好说的，先检查浏览器是否支持 `Service Worker`，如果支持，则注册离线逻辑。

```javascript
if ('serviceWorker' in navigator) {
  // 如果浏览器支持
  // 则把离线逻辑注册到 Service Worker 中
  navigator.serviceWorker.register('./sw.js')
}
```

注意把收到消息的事件逻辑注册到 service worker 中，以便在离线状态下也可以执行。

### 2. 检查订阅

`navigator.serviceWorker.register` 方法返回一个 `Promise` 对象，注册成功后，我们先检查用户是否已经订阅了此站点的推送：

```javascript
navigator.serviceWorker.register('./sw.js')
  .then(reg => {
    reg.pushManager.getSubscription()
      .then(subscription => {
        if (!subscription) {
          subscribe(reg)
        }
      })
  }).catch(err => {
    console.error('Registration failed with ' + err)
  })

function subscribe (reg) {
  // 订阅逻辑...
}
```

`navigator.serviceWorker.register` 在注册成功后的会 resolve 一个 `ServiceWorkerRegistration` 对象（[详细文档](https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerRegistration)），我们通过属性 `ServiceWorkerRegistration.pushManager` 管理推送的订阅、状态等。

`ServiceWorkerRegistration.pushManager.getSubscription` 方法返回当前浏览器对此站点的订阅信息 `pushSubscription`。如果 resolve 的 `pushSubscription` 对象为空，则进行订阅操作；否则，说明浏览器之前已经订阅过此站点，不需要重复订阅。

### 3. subscribe()

假设浏览器尚未订阅此站点的推送，则我们在检查后需要对站点推送进行订阅操作。我们现在实现 `subscribe` 方法：

```javascript
function subscribe (reg) {
  const publicKey = 'xxxxxx'
  reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlB64ToUint8Array(publicKey)
  }).then(pushSubscription => {
    // 把订阅信息保存到服务器，以便服务器做定向推送
  }).catch(error => {
    console.error('Subscription failed with ' + error)
  })
}

function urlB64ToUint8Array (base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4)
  const base64 = (base64String + padding)
    .replace(/\-/g, '+')
    .replace(/_/g, '/')

  const rawData = atob(base64)
  const outputArray = new Uint8Array(rawData.length)

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i)
  }
  return outputArray
}
```

以上代码，我们调用 `ServiceWorkerRegistration.pushManager.subscribe` 方法时提供了两个可选属性：

`userVisibleOnly` 属性的值为 `true` 时，代表此订阅只对用户可见的推送消息有效。值得注意的是，Chrome 目前仅支持此属性值为 true，即不可见推送将不被 Chrome 浏览器接收。如果你设置了 `userVisibleOnly: false`，将在 Chrome 上看到这样的错误：

```
Chrome currently only supports the Push API for subscriptions that will result in user-visible messages. You can indicate this by calling pushManager.subscribe({userVisibleOnly: true}) instead. See [https://goo.gl/yqv4Q4](https://goo.gl/yqv4Q4) for more details.
```

`applicationServerKey` 实际上是一对加密秘钥（[Public-key cryptography](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)）的公钥。秘钥加密算法保证了消息的安全性。最简单的，你可以通过访问 [https://web-push-codelab.glitch.me/](https://web-push-codelab.glitch.me/) 来生成一对秘钥。**要十分谨慎的是，千万不要将你的私钥分发到客户端，客户端代码中应该仅使用公钥，私钥应该存放在服务器安全的地方。**

### 4. PushSubscription

`ServiceWorkerRegistration.pushManager.subscribe` 方法返回的 `Promise` 对象会在成功后 resolve 一个 `PushSubscription` 对象，该对象包含了完整的订阅信息，具体结构如下：

```json
{
  "endpoint": "https://some.pushservice.com/something-unique",
  "keys": {
    "p256dh": "BIPUL12DLfytvTajnryr2PRdAgXS3HGKiLqndGcJGabyhHheJYlNGCeXl1dn18gSJ1WAkAPIxr4gK0_dQds4yiI=",
    "auth": "FPssNDTKnInHVndSTdbKFw=="
  }
}
```

在调用 `ServiceWorkerRegistration.pushManager.subscribe` 方法时，浏览器会带着你提供的公钥去推送服务的提供商申请一个网络请求，该服务会生成一个**唯一的** `endpoint`。浏览器拿到返回的 `endpoint` 后，将其附到 `PushSubscription` 对象上，此 `endpoint` 属性即是为该订阅提供推送服务的地址。

`keys` 对象包含了用来对服务器发送的推送消息进行加密的字段，（具体的协议可以看[这里](https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol)）。

在订阅成功并取得完整的 `PushSubscription` 对象后，客户端需要将此完整信息保存到服务器。当服务器需要推送消息时，便可以从此对象中获取完整的秘钥及推送地址。

*服务器端代码在此省略了，我使用了 node 实现，如果你也想使用 node 及 npm 的话，可以安装 [web-push](https://github.com/web-push-libs/web-push) 包。*

### PushEvent

至此，我们已经成功订阅了此站点。当服务器向该订阅推送消息时，我们需要捕获相关的事件并处理对应的数据，向用户展示推送消息。还记得我们之前在 `ServiceWorker` 中注册过一个 `sw.js` 的文件吗？我们需要将推送事件的处理逻辑放到这里，以便在页面不在线时也可以对事件进行捕获。

关于 `Worker` （`ServiceWorker` 也继承自 `Worker`）的内容不在此做详细赘述，我们这里只需知道 `Worker` 执行的上下文与浏览器环境不同，其有一个全局变量 `WorkerGlobalScope`，包含了 `事件(events handler)`，`console` 对象及 [`WorkerNavigator`](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope) 对象。通常，我们可以用 `WorkerGlobalScope.self` 来引用 `WorkerGlobalScope` 自身，在注册到 `Worker` 上的文件里，直接使用 `self` 全局属性：

```javascript
self.addEventListener('push', event => {
  const data = event.data.json()

  event.waitUntil(
    self.registration.showNotification(
      data.title,
      {
        body: data.body,
        icon: './icon.png',
        badge: './icon.png'
      }
    )
  )
})
```

当捕获到 `push` 事件时，我们会获取一个 [`PushEvents`](https://developer.mozilla.org/en-US/docs/Web/API/PushEvent) 对象，其中服务端发送的数据可通过 `PushEvents.data` 获取，类型是一个 [`PushMessageData`](https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData) 对象。

将 `PushMessageData` 中的数据进行简单提取后，我们便可以使用 `self.registration.showNotification` 方法向用户展示消息。但你可能已经注意到，我将这条指令作为参数传递给了 `PushEvents.waitUntil` 方法，这个方法在这里又起到了什么作用呢？

`PushEvents.waitUntil` 实际上继承自 `PushEvents` 的父类 `ExtendableEvent`，其目的是为了扩展事件的生命周期，在 `Service Worker` 中延长事件的寿命从而阻止浏览器在事件中的异步操作完成之前终止 `Service Worker`，以确保我们的代码能完整执行。

## 总结

以上是 `Web Push` 的一个简单实现，还有许多的特性及事件在这里没有展示到。如果你想自己撸一个，网上也有大量优秀的 demo 可供参考。当然，你也可以使用一些优秀的开箱即用工具，如 `web-push` 等，在工程中，使用既有工具永远是比自己造轮子更优的方案。
