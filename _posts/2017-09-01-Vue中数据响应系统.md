---
layout: default_post
---

之前学习了一些Vue源码，参照着自己实现了一套数据响应系统。因为文笔堪忧，一直没有去归纳整理。趁最近忙完了项目闲得慌，赶紧来回顾一下当时学习的内容，和大家一起分享~

*注：目前Vue版本已经是2.4.2版本了，当时学习源码时看的是2.1.7版本。不过基于我们本篇只讨论数据响应系统，应该没有大的变动。*

# 访问器属性

不同于Angular1与React，访问器属性(getter-setter pair)是Vue中数据响应的基石。之前写的一篇博客简单介绍过访问器属性（[戳我](https://karlbao.github.io/blog/2016/07/05/setter-getter-pair%E5%92%8Cproperty-descriptor.html)）。

在讲Vue的数据响应系统之前，我们先看以下例子：

```javascript
let obj = {
  name: 'karl'
}

// 定义访问器属性
Object.defineProperty(obj, 'name', {
  get () {
    console.log('Get property \'name\'')
  }
  set (newVal) {
    console.log('Set property \'name\' as ' + newVal)
  }
})
```

以上例子在`obj.name`属性上定义了一个存取描述符，允许定义`set`和`get`两个方法。当访问`obj.name`属性时，`get`方法会被调用。而当重新设置`obj.name`属性的值时，`set`方法会被调用, 并且将新的值作为参数传入方法。

```javascript
obj.name // Get property 'name'
obj.name = 'KarlBao' // Set property 'name' as KarlBao
```

好了，现在我们已经实现了最最最最基本的第一步 ———— 响应数据的变化。只要将回调放到`set`方法中，就可以对数据的变化进行响应了。

听起来不错喔~ 但注意了，我们在`get`中似乎忽略了最基本的职能 ———— 返回`name`的值。当然我们不可以直接返回`this.name`，这会导致`get`被无限循环调用而堆栈爆炸。因此，一个比较可行的办法是在访问器外部封装一层，并将值记录在一个临时变量中：

```javascript
// 将属性转换为访问器属性
function defineReactive (obj, key, val) {
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get () {
      console.log(`Get property ${key}`)
      return val // 返回临时记录的属性值，防止陷入无限回调
    }
    set (newVal) {
      console.log(`Set property ${key} from ${val} to ${newVal}`)
      val = newVal
    }
  })
}
```

`defineReactive`将属性转换为访问器属性，我们在方法中传入了`obj`,`key`,`val`三个参数。没错，`val`临时记录了`obj[key]`的值，因此在`get`中我们可以直接返回`val`的值，从而避免了陷入`get`方法的无限调用。

现在我们的访问器属性已经实现了属性本身的**取值**与**赋值**功能，便可以对其进行拓展了。在这之前，我们要先把对象上的所有属性及其子孙属性都转换为访问器属性：

```javascript
/**
 * observer.js
 */
class Observer {
  constructor (obj) {
    this.obj = obj
    this.walk(obj)
  }
  // 给对象中所有属性转换为访问器属性
  walk (obj) {
    const keys = Object.keys(obj)
    keys.forEach(key => {
      defineReactive(obj, key, obj[key])
    })
  }
}

// 将属性转换为访问器属性
function defineReactive (obj, key, val) {
  // 递归观察子属性
  observe(val)
  // 将属性转换为访问器属性
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get () {
      console.log(`Get property ${key}`)
      return val // 返回临时记录的属性值，防止陷入无限回调
    }
    set (newVal) {
      console.log(`Set property ${key} from ${val} to ${newVal}`)
      val = newVal
      observe(newVal)
    }
  })
}

export default observe = (data) => {
  if(!isObject(data)) {
    return
  }
  // 如果传入的是对象，则递归观察其子属性
  new Observer(data)
}

function isObject (data) {
  return Object.prototype.toString.call(data) === '[object Object]'
}
```

在observer.js文件中，我们实际暴露的是`observe`监测方法。如果传入的参数是一个对象，则通过`Observer`监测该对象，`Observer`中的`walk`方法将遍历对象中的属性，并通过`defineReactive`方法将其转为访问器属性。当然，`walk`中并不判断对象的属性是否拥有子属性，因此在`defineReactive`中对传入的值进行监测。如果其属性值也是对象，则会对该值进行递归调用。


至此，我们已经可以通过`observe(obj)`将对象中的所有属性注册为可响应的了。

想想下一步我们想要什么

。。。

。。。

。。。

Emmmm

对了，我们需要自定义注册每个属性变化后的响应事件。这样，便可以在数据变化后进行一系列骚操作了。

# Vue的数据响应系统

Vue的数据响应系统由三个部分组成：Observer, Dep 和 Watcher。