---
layout: default_post
---

之前学习了一些Vue源码，参照着自己实现了一套数据响应系统。因为文笔堪忧，一直没有去归纳整理。趁最近忙完了项目闲得慌，赶紧来回顾一下当时学习的内容，和大家一起分享~

*注：目前Vue版本已经是2.4.2版本了，当时学习源码时看的是2.1.7版本。不过基于我们本篇只讨论数据响应系统，应该没有大的变动。*

# 访问器属性

不同于Angular1与React，访问器属性(getter-setter pair)是Vue中数据响应的基石。之前写的一篇博客简单介绍过访问器属性（[戳我](https://karlbao.github.io/blog/2016/07/05/setter-getter-pair%E5%92%8Cproperty-descriptor.html)）。

在讲Vue的数据响应系统之前，我们先看以下例子：

```javascript
let obj = {
  name: 'karl'
}

// 定义访问器属性
Object.defineProperty(obj, 'name', {
  get () {
    console.log('Get property \'name\'')
  }
  set (newVal) {
    console.log('Set property \'name\' as ' + newVal)
  }
})
```

以上例子在`obj.name`属性上定义了一个存取描述符，允许定义`set`和`get`两个方法。当访问`obj.name`属性时，`get`方法会被调用。而当重新设置`obj.name`属性的值时，`set`方法会被调用, 并且将新的值作为参数传入方法。

```javascript
obj.name // Get property 'name'
obj.name = 'KarlBao' // Set property 'name' as KarlBao
```

好了，现在我们已经实现了最最最最基本的第一步 ———— 响应数据的变化。只要将回调放到`set`方法中，就可以对数据的变化进行响应了。

听起来不错喔~ 但注意了，我们在`get`中似乎忽略了最基本的职能 ———— 返回`name`的值。当然我们不可以直接返回`this.name`，这会导致`get`被无限循环调用而堆栈爆炸。因此，一个比较可行的办法是在访问器外部封装一层，并将值记录在一个临时变量中：

```javascript
// 将属性转换为访问器属性
function defineReactive (obj, key, val) {
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get () {
      console.log(`Get property ${key}`)
      return val // 返回临时记录的属性值，防止陷入无限回调
    }
    set (newVal) {
      console.log(`Set property ${key} from ${val} to ${newVal}`)
      val = newVal
    }
  })
}
```

`defineReactive`将属性转换为访问器属性，我们在方法中传入了`obj`,`key`,`val`三个参数。没错，`val`临时记录了`obj[key]`的值，因此在`get`中我们可以直接返回`val`的值，从而避免了陷入`get`方法的无限调用。

现在我们的访问器属性已经实现了属性本身的**取值**与**赋值**功能，便可以对其进行拓展了。在这之前，我们要先把对象上的所有属性及其子孙属性都转换为访问器属性：

```javascript
/**
 * observer.js
 */
class Observer {
  constructor (obj) {
    this.obj = obj
    this.walk(obj)
  }
  // 给对象中所有属性转换为访问器属性
  walk (obj) {
    const keys = Object.keys(obj)
    keys.forEach(key => {
      defineReactive(obj, key, obj[key])
    })
  }
}

// 将属性转换为访问器属性
function defineReactive (obj, key, val) {
  // 递归观察子属性
  observe(val)
  // 将属性转换为访问器属性
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get () {
      console.log(`Get property ${key}`)
      return val // 返回临时记录的属性值，防止陷入无限回调
    }
    set (newVal) {
      console.log(`Set property ${key} from ${val} to ${newVal}`)
      val = newVal
      observe(newVal)
    }
  })
}

export default observe = (data) => {
  if(!isObject(data)) {
    return
  }
  // 如果传入的是对象，则递归观察其子属性
  new Observer(data)
}

function isObject (data) {
  return Object.prototype.toString.call(data) === '[object Object]'
}
```

在observer.js文件中，我们实际暴露的是`observe`监测方法。如果传入的参数是一个对象，则通过`Observer`监测该对象，`Observer`中的`walk`方法将遍历对象中的属性，并通过`defineReactive`方法将其转为访问器属性。当然，`walk`中并不判断对象的属性是否拥有子属性，因此在`defineReactive`中对传入的值进行监测。如果其属性值也是对象，则会对该值进行递归调用。


至此，我们已经可以通过`observe(obj)`将对象中的所有属性注册为可响应的了。

```javascript
const data = {
  a: 'a',
  b: 'b'
}
observe(data)
data.a // Get property a
data.b = 'bb' // Set property b from b to bb
```

想想下一步我们想要什么

。。。

。。。

。。。

Emmmm

对了，我们需要注册每个属性变化后的自定义响应事件。

这样，便可以在数据变化后进行一系列骚操作了。

# Vue的数据响应系统

Vue的数据响应系统由三个部分组成：Observer, Dep 和 Watcher。

在上一段我们已经创建了一个基本的Observer，现在需要通过Watcher向被监视的属性添加回调，类似于：

```javascript
function handler (newVal, oldVal) {
  console.log(`old value : ${oldVal}, new value : ${newVal}`)
}
new Watcher(data, 'a', handler)
```

我们希望在属性`a`的值改变后，改变前后的值作为参数被传入我们自定义的回调函数中。为了联系起Observer和Watcher，我们需要通过Dep作为依赖收集器，收集Watcher中定义的回调函数。当下一次触发监视属性的`getter`时，我们可以检查有没有未被收集的依赖，如果有，则将其注册到该属性的依赖收集器中。

一步步来分解，首先，我们先定义一个Dep：

```javascript
// dep.js

export class Dep {
  constructor () {
    this.watchers = [] // 所有依赖收集在此数组中
  }
  // 添加事件
  addWatcher () {
    // 收集依赖时执行
    if (Dep.target !== null) {
      this.watchers.push(Dep.target)
    }
  }

  notify (newVal, oldVal) {
    // 当属性值改变时触发通知
    for (let i = 0; i < this.watchers.length; i++) {
      let watcher = this.watchers[i]
      watcher.fn.call(watcher.vm, newVal, oldVal)
    }
  }
}

Dep.target = null

export function pushTarget(watcher) {
  Dep.target = watcher
}

export function popTarget() {
  Dep.target = null
}
```

这里有一个小技巧。在依赖被收集之前，它们是被暂存在`Dep.target`中的（当然也可以是其他任意变量），因此每次我们只需检查`Dep.target`是否为空，就能知道是否需要收集依赖。不过，收集依赖是Observer的工作，对于Watcher而言，它只需要将依赖推送给`Dep.target`：

```javascript
// watcher.js
import { pushTarget, popTarget } from './dep'

export class Watcher {
  constructor(data, prop, fn) {
    this.vm = data
    this.prop = prop
    this.fn = fn
    pushTarget(this)
    data[prop]
    popTarget(this)
  }
}
```

注意在我们推送依赖之后，有一行`data[prop]`却没有给任何变量赋值的操作。在一般情况下，这种获取却不赋值的操作可能没有任何意义，但别忘了，这里我们`data`的属性都已经被转成了访问器属性。当我们获取`data[prop]`时，该属性的getter方法会被执行。通过这个操作，我们相当于可以间接暗示访问器去收集依赖，并在这之后通过`popTarget`清空临时变量。至此，依赖在暂存后被立即收集并清空，防止了多个属性注册依赖时可能出现的错乱。

接下来，只需要在访问器getter中增加一句检查依赖的语句，并在setter中触发该依赖回调，即可实现自定义回调函数的响应：

```javascript
// observer.js

// 以上省略...
function defineReactive (obj, key, val) {
  observe(val)
  let dep = new Dep() // 创建依赖收集器
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      dep.addWatcher() // 检查并收集依赖
      return val
    },
    set: function reactiveSetter (newVal) {
      if (val === newVal) {
        return
      }
      val = newVal
      observe(newVal)
      dep.notify(newVal, val) //触发依赖回调
    }
  })
}
// 以下省略...
```