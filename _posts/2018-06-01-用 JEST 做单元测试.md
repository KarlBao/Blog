---
layout: default_post
---

随着前端业务的越来越复杂，对前端工程进行测试已经变得越来越重要。维护一套好的测试用例，对于项目的迭代、交接都有着重要的作用。

目前比较流行的单元测试工具有比较老的 Mocha (读作“摩卡”，不是“抹茶”！)，以及后来由 Facebook 推出的 Jest。我使用的是 Jest，相比较 Mocha，Jest的配置更简单（甚至可以零配置启动），功能更丰富，代码更简洁，并且能简单地集成 babel。让测试代码可以无缝适应我们的各种开发环境，而不用为了测试而对开发过程作出妥协。

这篇文章会对 Jest 的配置及使用作一些简单的介绍。如果你是首次接触单元测试，这也可以作为你入门的一篇小指南。

## 快速使用

Jest 允许几乎零配置启动，你只需要通过 `npm install jest --save-dev` 安装， 并在 `package.json` 中添加以下命令便可使用：

```json
{
  "script": {
    "test": "jest"
  }
}
```

完成了，现在输入命令 `npm test`，Jest 便会寻找当前目录下的测试用例并在控制台中输出你的测试报告！但目前我们还没有添加测试用例，会得到 `No tests found` 的错误。让我们创建文件 `test.spec.js`，并添加一个简单的测试用例试试：

```javascript
// test.spec.js
describe('测试demo', () => {
  test('一个简单的测试', () => {
    expect(1+1).toBe(2)
  })
})
```

Jest 会匹配到 `test.spec.js` 文件（可以通过配置 `testMatch` 属性设置匹配的正则规则，默认配置下为 `**/__tests__/**/*.js?(x),**/?(*.)+(spec|test).js?(x)`），并执行其中的测试代码。通常我们在 `describe` 下定义一组测试套件(suite)，包含一个或多个测试以 `test` 方法定义的测试用例(test)。在以上这个例子中，我们在 `expect` 中定义要执行的方法，在 `toBe` 中断言正确情况下得到的结果。要了解更多API及测试能力，可以查看[官方文档](https://facebook.github.io/jest/docs/zh-Hans/using-matchers.html)。

现在我们再执行 `npm test` 命令，测试通过！我们可以在控制台看到 Jest 打印的测试通过率，耗费时间等信息。

## 进阶配置

更多情况下，我们需要在工程中通过灵活的配置来适应开发环境。要进行自定义的配置，只需要在 `package.json` 中添加 `jest` 属性：

```json
{
  "jest": {}
}
```

Jest 允许开发者进行灵活的自定义配置，因此配置属性也很多，如果要了解，可以参考[官方文档](https://facebook.github.io/jest/docs/zh-Hans/configuration.html)。这里我们来介绍一些常用的自定义配置：

> 教练，我想上 Babel

我不想写狗屎一样的 CJS 模块，幸好 Jest 很方便得支持了 Babel。要在测试代码中使用 ES6+，只需要安装 `babel-core`, `babel-preset-env` 及 `babel-jest`，并在项目根目录新建一个 `.babelrc` 配置文件：

```json
{
  "presets": [["env", {"modules": false}]],
  "env": {
    "test": {
      "presets": [["env"]]
    }
  }
}
```

其实只是多加了一个 `babel-jest` 包，我们便可以在测试代码中自由得使用 `ES6+` 语法了。

Jest 在默认配置下已经会走 `babel-jest`，如果你重新配置了 `transform` 属性，则会将默认的配置覆盖掉。这种情况下，如果你扔需要使用 `babel-jest`，需记得手动加上该配置：

```json
"jest": {
  "transform": {
    ".+\\.jsx?$": "<rootDir>/node_modules/babel-jest"
  }
}
```

> 教练，我想上 TypeScript

Visual Studio Code 对 TypeScript 作了很好的支持，配合食用，开发体验极佳。习惯了使用 TypeScript 进行工程开发，就不愿意回头再去嚼 JavaScript 的屎了。

想要在 Jest 测试用例中使用 TypeScript，需要安装 `ts-jest` 和 `@types/jest`：

```powershell
npm install ts-jest @types/jest --save-dev
```

Jest 默认配置中不会去读取 `ts` 文件，我们需要在配置中加上以下选项：

```json
{
  "jest": {
    "moduleFileExtensions": [
      "js",
      "jsx",
      "json",
      "ts",
      "tsx"
    ],
    "transform": {
      ".+\\.tsx?$": "<rootDir>/node_modules/ts-jest"
    },
    "testMatch": [
      "**/__tests__/**/*.(js|ts)?(x)",
      "**/?(*.)(spec|test).(js|ts)?(x)"
    ]
  }
}
```

如果还想同时支持 Babel，则还需要配置以下属性：

```json
{
  "jest": {
    "globals": {
      "ts-jest": {
        "useBabelrc": true
      }
    }
  }
}
```

因为重新配置了`transform`， 别忘记在手动配上 `babel-jest`：

```json
{
  "jest": {
    "transform": {
      ".+\\.jsx?$": "<rootDir>/node_modules/babel-jest",
      ".+\\.tsx?$": "<rootDir>/node_modules/ts-jest"
    }
  }
}
```

齐活。

现在 Jest 会去查找 `ts` 及 `tsx` 文件并过 `ts-jest` 编译，并且 `@types/jest` 也让开发过程资瓷了**类型提示**。开发体验和逼格都上升了一个档次。

> 教练，还能再炫酷点吗

在编写严格的测试用例时，我们需要知道是否所有代码和分支都被覆盖到。Jest 允许我们收集测试覆盖率，直观得了解哪些代码还没有被测试到：

```json
{
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{js,jsx,ts,tsx}",
      "!**/node_modules/**",
      "!src/**/*.d.ts"
    ]
  }
}
```

在 `collectCoverageFrom` 数组中定义需要被覆盖的文件的正则规则，现在我们再运行 `npm test` 命令，报告中可以看到测试用例的代码覆盖率了。

在多人项目，或者持续集成测试中，如果需要生成更直观的测试报告文件，我们只需在配置中指定测试报告生成路径：

```json
{
  "jest": {
    "coverageDirectory": "<rootDir>/.coverage-report"
  }
}
```

Jest 便会在每一次运行后生成对应的直观的测试报告文件，包括可以直接浏览的 HTML。
